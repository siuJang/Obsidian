![[컴퓨터구조_2장_김현석.pdf]]
## 디지털 정보의 단위
- 1nibbler = 4bit
- 1byte = 8bit
- 1byte = 1문자(character)
- 영어는 1byte 한글은 2byte필요
- 1워드: 특정 cpu에서 취급하는 명령어나 데이터길이에 해당하는 비트 수
- 워드 길이는 8의 배수로 8'16'32 이런식으로 가능하다
- MSB:최상위비트
- LSB:최하위비트
### SI 단위와 IEC 단위 비교
SI(10진수 단위), IEX(2진수 단위)
ex) si = 1k=1000 iex= 2^10 =1024
## 진법
### 10 진법
- 10진수:기수가 10인수
- 0,1,2,3,4,5,6,7,8,9 의 10개 수로 표현
### 2 진법
- 기수가 2인수
- 0, 1 두 개의 수로 표
### 8 진법
- 0~7까지 8개의 수로 표현
### 16 진법
- **한자리 숫자로 더 많은 경우를 표현할 수 있음**
- 0~9,A~F까지 16개의 기호로 표현
- 8진수보다는 16진수를 많이씀 ->**자릿수를 더 짧게 표현할 수 있기 때문**
## 아스키코드(HEX)
- 디지털포렌식 할 때 사용
**-이건 꼭 왜우자-**
**0x31 : 1 ~ 0x39 : 9**
**0x41 : A ~ 0x5A : Z**
**0x61 : a ~ 0x7A : Z**
## 진법 변환
- 2,8,16 -> 10 진수 변환은 쉬움
ex) $$1010.01 -> 
1\times2^3+0\times2^2+1\times2^1+0\times2^0+0\times2^{-1}+1\times2^{-2}$$```
- 10->2,8,16 진수 변환은 ppt참고
- 보통 10->8,16 진수 변환은 어렵기에 2진수로 변환 후 2->8,16 진수로 바꿈
ex)2진수 to 8진수 -> 1101.01 -> 8진수는 2^3승이기에소수점 기준 3자리씩 나눠서 001 101 . 010 ->15.2
따라서 16진수는 2^4승이므로 4자리씩 하면됨
## 보수
- 수학에서는 무한대의 수가존재 but 컴퓨터는 유한개의 수가 존재하기에 순환버퍼(원형으로 돔)가 됨
### 보수의 개념과 음수
- 부호와 절댓값 방법 : 최상위 비트(MSB)를 부호비트로 두고 0이면 양수, 1이면 음수로 보는 방법
- 1의 보수 방법 : 0->1, 1->0으로 변환
ex) 00010001->11101110
- **2의 보수 방법** : 1의 보수 방법에 +1 해주기
ex) 00010001->11101110+1 ->11101111
- 컴퓨터에서는 2의 보수 방식을 사용
### 2의보수에 대한 10진수의 표현범위
-2^n-1 ~ +2^(n-1)-1 
### 부호확장
2의보수
- 8비트-> 16비트일때 양수 00101010-> 0000000000101010 음수 10010111->1111111110010111
### 오버플로우&언더플로우
비트별 표현범위를 넘어서면 오버플로우 현상이 발생함 양수범위넘어서면 음수로가고 음수는 반대
## 실수
- 부동소수점을 이용해 표현 -> 더 넓은 범위의 실수 표현이 가능해짐
- **부호 지수 가수**로 표현
### 정규화
10진수를 2진수로 정규화 한다고 치면 10진수를 2진수로 먼저바꾸고 소수점 자리가 1.이 될때까지 올린후 소수점 밑에 숫자들이 **가수**고 **지수**는 소수점 올린만큼에 바이오스값 더하고 **부호**는 양수면 0 음수면 1 하면 됨.
## 디지털 코드
### BCD 코드(2진화 10진코드)
- 전자제품에서 많이 사용
- 자료 표 확인
- 연산할때 10진수 처럼 가능
ex) 19 = 0001 1001, 237 = 0010 0011 0111
### 그레이 코드
- 가중치가 없는 코드이기 때문에 연산에는 불리하지만, 아날로그-디지털 변환기나 입출력 장치 코드로 주로 쓰인다.
- 연속되는 코드들 간에 하나의 비만 변화하여 새로운 코드가 된다.
- 2진코드와 그레이 코드의 상호변환 방법
F=A⨁B사용(XOR) 자세한건 자료 참고
### 아스키 코드
- 정보 교환용 미국 표준 코드
- 128가지 문자 표현 가능
### 유니코드
- 아스키코드의 한계성을 극복하기 위하여 개발된 인터넷 시대의 표준
- 유니코드는 거의 모든 언어를 표현할 수 있음
- 앞으로도 계속해서 산업계의 요구나 새로운 문자들을 추가
## 에러 검출 코드
### 패리티 비트
- 짝수패리티 : 데이터에서 1의 개수를 짝수 개로 맞춤
- 홀수패리티 : 1의 개수를 홀수 개로 맞춤
- 패리티 비트는 데이터 전송과정에서 에러검사를 위한 코
- 패리티는 단지 에러 검출만 가능하며, 여러비트에서 에러가 발생할 경우에는 검출이 안될수도 있음
### 해밍 코드
- 에러를 정정할 수 있는 코드
- 추가적으로 많은 비트가 필요하므로 많은 양의 데이터 전달이 필요
- **$2^p>=d+p+1$을 만족하는 p값만큼 추가 비트가 필요함
- 해밍코드에서는 **짝수 패리티**를 사용
- 계산방법은 자료참고
- 검사된 패리티를 P8P4P2P1순으로 정렬
- 계산 후 결과에 하나라도 1 이 있으면 에러발생
- 결과값은 10진수로 바꾸면 몇번째 비트가 잘못됫는지 알 수 있음
### 순환 중복 검사(CRC)
- 높은 신뢰도를 확보하며 에러 검출을 위한 오버헤드가 적고, 랜덤 에러나 버스트 에러를 포함한 에러 검출에 매우 좋은 성능을 갖는다
- 방법은 자료 참
## Byte Ordering
- 바이트 단위로 메모리 저장 또는 통신 전송되는 순서 
- 2바이트 이상인 경우부터 차이가 남
### Big-Endian
- 상위 바이트 하위 번지에 저장
- RISC 계열의 CPU
- 네트웍 통신(TCP/IP 등)
### Little-Endian
- 하위 바이트가 하위 번지에 저장
- Intel 계열의 CPU

