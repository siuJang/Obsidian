## 리스트 종류
### **리스트(List)**
- 일반적으로 사용되는 파이썬의 시퀀스 데이터 형식입니다.
- 대괄호 `[]`로 정의되며, 항목은 쉼표로 구분됩니다.
- 리스트는 인덱싱과 슬라이싱이 가능하며, 수정 가능한(mutable) 시퀀스 자료형입니다.
```python
my_list = [1, 2, 3, '사과', '바나나']
print(my_list[3])  # '사과' 출력
```
### **튜플(Tuple)**
- 리스트와 유사하지만, 불변(immutable)한 시퀀스 자료형입니다.
- 괄호 `()`로 정의되며, 항목은 쉼표로 구분됩니다.
- 튜플은 리스트와 마찬가지로 인덱싱과 슬라이싱이 가능하지만, 한 번 정의되면 내용을 변경할 수 없습니다.
```python
my_tuple = (1, 2, 3, '사과', '바나나')
print(my_tuple[4])  # '바나나' 출력
```
### **딕셔너리(Dictionary)**
- 키(key)와 값(value)의 쌍으로 이루어진 데이터 구조입니다.
- 중괄호 `{}`로 정의되며, 각 항목은 키와 값을 콜론 `:`으로 구분하여 정의합니다.
- 딕셔너리는 키를 사용하여 값에 접근하고, 항목을 추가, 수정 또는 제거할 수 있습니다.
```python
my_dict = {'number': 10, 'fruit': '사과'}
print(my_dict['fruit'])  # '사과' 출력
```
### **세트(Set)**
- 중복되지 않는 항목의 컬렉션입니다.
- 중괄호 `{}`로 정의되며, 항목은 쉼표로 구분됩니다.
- 예를 들어, `my_set = {1, 2, 3, 4, 5}`와 같이 정의할 수 있습니다.
- 세트는 항목의 순서를 보장하지 않으며, 항목을 추가하거나 제거하고, 합집합, 교집합, 차집합 등의 집합 연산을 수행할 수 있습니다.
```python
my_set = {1, 2, 3, 3, 2}
print(my_set)  # {1, 2, 3} 출력
```

각 자료구조는 특정 상황에서 유용합니다. 예를 들어, 리스트와 튜플은 데이터를 순차적으로 저장할 때 사용되고, 세트는 중복을 허용하지 않는 유일한 값을 저장할 때, 딕셔너리는 키를 통해 빠르게 데이터를 검색할 때 사용됩니다. 또한, 스택이나 큐와 같은 다른 추상 자료형을 구현할 때도 이러한 자료구조들이 활용됩니다.



## 리스트 자료 구조
### 리스트의 선언
```python
my_list = [1, 2, 3, '사과', '바나나']
print(my_list[3])  # '사과' 출력
```
### 첨자(Index)
- 파이썬에서 리스트 자료형의 첨자(index)는 리스트 내의 특정 요소를 가리키는 숫자입니다
- 리스트의 첨자는 0부터 시작하여 리스트의 길이보다 하나 작은 값까지 할당됩니다
- 첨자를 사용하여 리스트의 특정 요소에 접근하거나, 그 요소를 변경할 수 있습니다.
```python
my_list = ['사과', '바나나', '체리', '딸기', '포도']

# 첫 번째 요소에 접근 (첨자 0)
print(my_list[0])  # '사과' 출력

# 마지막 요소에 접근 (첨자 -1)
print(my_list[-1])  # '포도' 출력

# 첨자를 사용하여 요소 변경
my_list[1] = '오렌지'
print(my_list)  # ['사과', '오렌지', '체리', '딸기', '포도'] 출력
```
### 리스트 함수
#### 자료 추가 함수
**append()** : 리스트의 맨 뒤에 새로운 값을 추가하고자 할 때 사용
```python
# 빈 리스트 생성
my_list = []

# append() 함수를 사용하여 리스트에 요소 추가
my_list.append('사과')
my_list.append('바나나')
my_list.append('체리')

# 결과 출력
print(my_list)
```
**insert()** : 리스트의 중간이나 특정 위치에 요소를 추가하고자 할 경우에 사용
```python
# 기존 리스트 생성
my_list = ['사과', '바나나', '체리']

# insert() 함수를 사용하여 인덱스 1에 '오렌지' 삽입
my_list.insert(1, '오렌지')

# 결과 출력
print(my_list)
```
#### 자료 삭제
**remove()** : 리스트에서 특정 값을 찾아서 제거할 때 사용
```python
my_list = [1, 2, 3, 4, 5]
my_list.remove(3)  # 3이라는 값을 찾아서 제거
print(my_list)  # [1, 2, 4, 5] 출력
```
**del** : 리스트의 특정 인덱스에 있는 값을 제거할 때 사용(함수 X)
```python
my_list = [1, 2, 3, 4, 5]
del my_list[2]  # 인덱스 2에 있는 요소(3)를 제거
print(my_list)  # [1, 2, 4, 5] 출력
```
#### 자료 탐색 함수
**index()** : 리스트에서 특정 요소를 찾을 때 사용
```python
# 리스트 생성
my_list = ['사과', '바나나', '체리', '사과']

# '사과'의 인덱스 찾기
index_of_apple = my_list.index('사과')

# 결과 출력
print(index_of_apple)  # 0 출력, '사과'의 첫 번째 인덱스
```
#### 리스트 요소 정렬 함수
sort() : 리스트 요소들을 오름차순(기본) 또는 내림차순으로 정렬
```python
# 리스트 생성
numbers = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]

# sort() 함수를 사용하여 오름차순으로 정렬
numbers.sort()
print(numbers)  # [1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9] 출력

# sort() 함수를 사용하여 내림차순으로 정렬
numbers.sort(reverse=True)
print(numbers)  # [9, 6, 5, 5, 5, 4, 3, 3, 2, 1, 1] 출력
```
reverse() : 리스트의 순서를 뒤집을 때 사용
```python
# 리스트 생성
numbers = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]

# reverse() 함수를 사용하여 순서 뒤집기
numbers.reverse()
print(numbers)  # [5, 3, 5, 6, 2, 9, 5, 1, 4, 1, 3] 출력
```
### 리스트 인덱싱, 슬라이싱
**인덱싱(Indexing)** : 리스트의 특정위치에 있는 요소에 접근하기 위해 사용, 0부터 시작
```python
my_list = ['사과', '바나나', '체리', '딸기', '포도']

# 첫 번째 요소에 접근 (첨자 0)
print(my_list[0])  # '사과' 출력

# 마지막 요소에 접근 (첨자 -1)
print(my_list[-1])  # '포도' 출력

# 첨자를 사용하여 요소 변경
my_list[1] = '오렌지'
print(my_list)  # ['사과', '오렌지', '체리', '딸기', '포도'] 출력
```
**슬라이싱(Slicing)** : 리스트의 일부분을 선택하여 새로운 리스트를 만드는 것
```python
fruits = ['사과', '바나나', '체리', '딸기']
print(fruits[1:3]) # 인덱스 1부터 2까지의 요소 ['바나나', '체리'] 출력
print(fruits[:2])  # 처음부터 인덱스 1까지의 요소 ['사과', '바나나'] 출력
print(fruits[2:])  # 인덱스 2부터 끝까지의 요소 ['체리', '딸기'] 출력
```
### 리스트 연결 및 중첩 리스트
```python
# 세 리스트를 정의합니다.
list1 = [1, 2, 3]
list2 = [4, 5, 6]
list3 = [7, 8 ,9]

# 두 리스트를 연결합니다.
combined_list = list1 + list2

# 리스트 안에 또 다른 리스트를 넣습니다
combined_list.append([list3])

# 연결된 리스트를 출력합니다.
print(combined_list)
```
## 튜플(Tuple) 자료 구조
- 요소를 직접 수정할 수 없다는 특징을 가짐
- 내용이 바뀌지 않는 상수 형태이기 때문에 딕셔너리 구조의 Key로도 사용 가능
- List에 비해 수정이 불가능하다는 단점이 있지만 실행 속도가 빠르고 가볍다는 장점이 있음
```python
# 괄호를 사용하여 튜플 생성하기
ex_tuple = (1, 2, 3)
print(ex_tuple)  # 결과: (1, 2, 3)

# List 구조처럼 Tuple 요소 수정해보기
ex_tuple[1] = 1000

#결과 보기
print(ex_tuple)
```
## 딕셔너리 자료 구조
### 딕셔너리 선언
```python
my_dict = {'number': 10, 'fruit': '사과'}
print(my_dict['fruit'])  # '사과' 출력
```
### 키(Key)와 밸류(Value)
- 딕셔너리는 리스트와 튜플이 요소에 접근할 때 인덱스(index)를 사용하는 것과 다르게 요소에 접근할때 키(Key)를 사용합니다!
```python
# 딕셔너리 구조 선언
dic = {}

# Key를 이용해 요소에 값 대입
dic["name"] = "홍길동"
dic["phone"] = "010-6631-9148"

# 딕셔너리 요소 확인
print(dict)

# Key를 이용해 출력해보기
print("Name => " + dic("name"))
print("Phone => " + dic("phone"))
```
keys() -> 키만 변수에 저장해주는 함수
values() -> value 만 변수에 저장해주는 함수
### 딕셔너리와 리스트 혼용
```python
# 딕셔너리 리스트 생성
students = [
    {'name': '김철수', 'grade': 90},
    {'name': '이영희', 'grade': 85},
    {'name': '박민수', 'grade': 92}
]

# 새로운 학생 정보 추가
students.append({'name': '최예진', 'grade': 88})

# 모든 학생의 이름과 성적 출력
for student in students:
    print(f"{student['name']}의 성적은 {student['grade']}입니다.")
```
## 셋 자료 구조
- 셋은 요소 하나하나가 모두 key이며 그 값들은 절대 중복될 수 없다는 특징을 가진 자료구조입니다
- 셋 구조에서는 요소를 추가할때 add() 메소드를 사용하고 요소를 제거할때 remove()와 discard() 메소드를 사용합니다
```python
# 셋 생성
my_set = {1, 2, 3}

# 셋에 요소 추가
my_set.add(4)

# 셋에 중복 요소 추가
my_set.add(1)
my_set.add(3)

# 셋에서 요소 제거
my_set.remove(2)

# 셋 출력
print(my_set)  # 출력: {1, 3, 4}
```
## 리스트와 반복문 for
```python
# 리스트와 for 반복문을 사용하여 각 요소를 출력하는 예시 코드

# 리스트 생성
fruits = ['apple', 'banana', 'cherry', 'date', 'elderberry']

# 리스트의 길이를 사용하여 range() 함수로 반복문 생성
for i in range(len(fruits)):
    # 현재 인덱스에 해당하는 리스트 요소 출력
    print(f'Index {i}: {fruits[i]}')
```
